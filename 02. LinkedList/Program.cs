namespace _02._LinkedList       // 연결 리스트
{
    internal class Program
    {
        // 배열의 경우 연속적으로 배치되어 원하는 항목의 위치를 금방 파악할 수 있음
        // 연결리스트는 연속적으로 저장하지 않음 -> 원하는 항목의 위치를 파악하기 어려움 : 때문에 해당 항목의 다음위치의 값까지 함께 보관함
        // 장점: 데이터를 끼워넣거나 뺄 때, 앞뒤로 미루고 당기는 과정이 불필요함

        /**********************************************************************************
         * 연결리스트 (Linked List) : C#에서 선호하지는 않는 자료구조임
         * 
         * 데이터를 포함하는 노드(마디/단계 - '데이터+추가정보'의 단위)들을 연결식으로 만든 자료구조
         * 데이터와 다른 데이터 지점의 참조변수를 가진 노드를 기본 단위로 사용
         * 데이터를 노드를 통해 연결식으로 구성하기 때문에 데이터의 추가/삭제에 유용
         * 노드가 메모리에 연속적으로 배치되지 않고 연결 구조로 다른 데이터의 위치를 확인
         ***********************************************************************************/

        // < 연결리스트 구현 >
        // 연결리스트는 노드를 기본 단위로 연결식으로 구현
        // 노드간의 연결구조에 따라 단방향, 양방향, 환형으로 구분

        // 1. 단방향 연결리스트
        // 노드가 다음 노드를 참조
        // ┌────┬─┐  ┌────┬─┐  ┌────┬─┐  ┌────┬─┐
        // │Data  │───→│Data  │───→│Data  │───→│Data │  │
        // └────┴─┘  └────┴─┘  └────┴─┘  └────┴─┘
        //
        // 2. 양방향 연결리스트 - C#
        // 노드가 이전/다음 노드를 참조
        // ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐
        // │  │Data  │←────→│Data  │←────→│Data  │←────→│Data │  │
        // └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘
        //
        // 3. 환형 연결리스트
        // 노드가 이전/다음 노드를 참조하며, 시작 노드와 마지막 노드를 참조
        //   ┌───────────────────────────────────────┐
        // ┌│┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬│┐
        // │↓│Data   │←────→│Data │←────→│Data  │←────→│Data │↓│
        // └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘

        // < 연결리스트 삽입 >
        // 새로 추가하는 노드가 이전/이후 노드를 참조한 뒤, 이전/이후 노드가 새로 추가하는 노드를 참조함
        // 
        //          ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐ 
        //          │ │ C │ │                    ┌───│ C │───┐                  ┌───│ C │───┐
        //          └─┴───┴─┘          =>        ↓ └─┴───┴─┘ ↓        =>        ↓ └─┴───┴─┘ ↓
        // ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐ ↑     ↑ ┌─┬───┬─┐
        // │ │ A │←───────────→│ B │ │    │ │ A │←───────────→│ B │ │    │ │ A │───┘     └───│ B │ │
        // └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘

        // < 연결리스트 삭제 >
        // 삭제하는 노드의 이전 노드가 이후 노드를 참조한 뒤, 삭제하는 노드의 이후 노드가 이전 노드를 참조함
        // 
        //          ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐
        //        ┌──→│ C │←──┐                    │ │ C │←──┐                    │ │ C │ │
        //        │ └─┴───┴─┘ │        =>          └─┴───┴─┘ │        =>          └─┴───┴─┘
        // ┌─┬───┬│┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐
        // │ │ A │↓│         │↓│ B │ │    │ │ A │──────────→│↓│ B │ │    │ │ A │←───────────→│ B │ │
        // └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘

        // < 연결리스트의 특징 > : 추가,삭제는 쉬우나 탐색이 어려움
        // 연결리스트의 경우, 데이터를 연속적으로 배치하는 배열과 다르게 연결식으로 구성
        // 따라서, 데이터의 추가/삭제 과정에서 다른 데이터의 위치와 무관하게 진행되므로 수월함
        // 하지만, 데이터의 접근과정에서 연속적인 데이터 배치가 아니기 때문에, 인덱스 사용이 불가하여 처음부터 탐색해야 한다

        // <LinkedList의 시간복잡도>
        // 접근    탐색    삽입    삭제
        // O(n)    O(n)    O(1)    O(1)

        static void Main(string[] args)
        {
           LinkedList<string> linkedList = new LinkedList<string>();

            // 삽입 : 반환형 node
            LinkedListNode<string> node0 = linkedList.AddFirst("0번데이터");   // 앞에 추가(노드생성) - 노드를 반환
            LinkedListNode<string> node1 = linkedList.AddLast("1번데이터");    // 뒤에 추가(노드생성)
            LinkedListNode<string> beforeNode0 = linkedList.AddBefore(node0,"0번 앞 데이터"); // (어떤 노드 앞에 붙일건지, 데이터값)
            LinkedListNode<string> afterNode0 = linkedList.AddAfter(node0,"0번 뒤 데이터");  // (어떤 노드 뒤에 붙일건지, 데이터값)

            // 삭제 
            bool sucess = linkedList.Remove("1번데이터"); // .Remove = - 찾아서 지우기 : 성공할 경우 true 반환
            bool fail = linkedList.Remove("1번데이터");   // 실패할 경우 fail 반환
            linkedList.Remove(node1);       // 노드를 직접 지정해줘서 지우는 것도 가능
            linkedList.RemoveFirst();       // 첫번째 노드 지우기
            linkedList.RemoveLast();        // 마지막 노드 지우기

            // 접근
            LinkedListNode<string> first = linkedList.First; // 첫번째 노드 찾기 (경고표시 뜨는 이유 : 존재하지 않을 수도 있기 때문에)
            LinkedListNode<string> last = linkedList.Last;   // 마지막 노드 찾기
            LinkedListNode<string> prev = node0.Previous;    // 기준 노드의 이전 항목 찾기
            LinkedListNode<string> next = node0.Next;        // 기준 노드의 다음 항목 찾기

            // 탐색
            LinkedListNode<string> findNode = linkedList.Find("0번데이터");


        }
    }
}
